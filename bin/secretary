#! /usr/bin/env python

"""This is a first implementation of the Secretary."""

# from ipython import embed
# import configparser
import time
import threading
import random
import pickle
import datetime
import pytz
import subprocess
import copy
import os
from configparser import ConfigParser
import os
from IPython import embed
import speech_recognition
import nltk
import lifedashboard.model as model
import lifedashboard.tasks
import yaml
import redis
import isodate
# class pdb:
#     DEBUG = True
#     def set_trace():
#         import pdb as pypdb
#         if pdb.DEBUG:
#             pypdb.set_trace()

import pdb

import os
    # Main Function is to add pomodoro_records_to

def getFocusDirectories(directory):
    focus_dirs = map(lambda fn: os.path.join(directory, fn), os.listdir(directory))
    focus_dirs = filter(os.path.isdir, focus_dirs)
    focus_dirs = filter(lambda dir: "description.yaml" in os.listdir(dir), focus_dirs)
    return list(focus_dirs)

def loadDatabaseData(config):
    focus_directory = config.get("focus_groups_directory", is_filename=True)
    focus_directories = getFocusDirectories(focus_directory)

    session = model.session()

    for focus_dir in focus_directories:
        parseFocusDirectory(session, focus_dir)

    emotional_states_file = config.get("emotional_states_file", section="conf", is_filename=True, default = False)

    loadEmotionalStatesFromFile(session, emotional_states_file)
    session.close()
    return

def loadEmotionalStatesFromFile(session, emotional_states_file):
    assert os.path.isfile(emotional_states_file), "Must provide conf::emotional_states_file in config"
    emotional_states = yaml.load(open(emotional_states_file))

    for (emotion, emotion_def) in emotional_states.items():
        if session.query(model.Emotion).filter(model.Emotion.name == emotion_def['name']).count():
            # print('emotion Exists')
            continue

        emotion = model.Emotion(**emotion_def)
        session.add(emotion)
    else:
        session.commit()
    return

def parseFocusDirectory(session, focus_dir):
    focus_file = os.path.join(focus_dir, "description.yaml")
    yaml_data = yaml.load(open(focus_file))

    focus = initializeFocusGroupFromFile(session, yaml_data)

    activities_dir = os.path.join(focus_dir, "activities")
    activity_files = filter(lambda fn: fn.endswith(".yaml") and "#" not in fn, map(lambda fn: os.path.join(activities_dir, fn), os.listdir(activities_dir)))
    for fn in activity_files:
        activity_data = yaml.load(open(fn))
        activity_data = initializeActivityFromFile(session, activity_data, focus)

    return

def initializeFocusGroupFromFile(session, focus_yaml):
    focus_qry = session.query(model.FocusGroup).filter(model.FocusGroup.name == focus_yaml['name'])
    if focus_qry.count():
        # print("focus group Exists")
        focus = focus_qry.first()
    else:
        focus = model.FocusGroup(name=focus_yaml['name'])
        session.add(focus)
        session.commit()
    return focus

def initializeActivityFromFile(session, activity_yaml, parent_focus):

    if session.query(model.Activity).filter(model.Activity.name == activity_yaml['name']).count():
        # print("activity Exists")
        return

    def loadOrDefault(dict, key, val):
        return dict[key] if key in dict else val

    activity_name = activity_yaml['name']
    activity_expected_pomodoro = loadOrDefault(activity_yaml, 'expected_pomodoro', 2)
    activity_progress = loadOrDefault(activity_yaml, 'progress', '0 per day')

    activity = model.Activity(name=activity_name,
                              expected_pomodoro=activity_expected_pomodoro,
                              progress = activity_progress,
                              focus_group = parent_focus)
    session.add(activity)
    session.commit()
    return


class AppConfigParser(ConfigParser):
    def get(self, config_param, section="app", type = None, is_filename = None, default = None):
        # super does not work b/c ConfigParser is an old style class.


        if default is not None:
            if not self.has_option(config_param, section = section): return default

        conf_val = ConfigParser.get(self, section, config_param)

        if type is not None:
            conf_val = type(conf_val)

        if is_filename is not None:
            conf_val = os.path.abspath(os.path.join(self.conf_directory, os.path.expanduser(conf_val)))

        return conf_val

    def has_option(self, config_param, section="app"):
        return ConfigParser.has_option(self, section, config_param)

    def read(self, fn):
        self.conf_directory = os.path.split(os.path.abspath(fn))[0]
        ConfigParser.read(self, fn)
        return

def getApplicationRecordFile():
    fn = "/Users/naddy/Source/lifedashboard/db/record.dat"
    return fn

def getApplicationConfigFile():
    fn = "/Users/naddy/Source/lifedashboard/conf/app.conf"
    return fn

def getApplicationConfig():
    config = AppConfigParser()
    config.read((getApplicationConfigFile()))
    return config

class Secretary:
    def __init__(self):
        return

    def initialize(self):
        config = getApplicationConfig()
        self.title_name = config.get("title_name")
        self.first_name = config.get("first_name")
        self.last_name = config.get("last_name")
        self.secretary_voice = config.get("secretary_voice", default="")
        self.secretary_rate = config.get("secretary_rate", default=0, type=int)
        self.timezone = pytz.timezone(config.get("timezone"))

        # self.schedules_directory = config.get("schedule_template_directory", is_filename=True)

        loadDatabaseData(config)
        return







    def say(self, thing):
        args = ["say", thing]
        if self.secretary_voice: args.extend(["-v", "{0}".format(self.secretaryvoice)])
        if self.secretary_rate: args.extend(["-r", "{0}".format(self.secretary_rate)])
        subprocess.call(args)
        return

    def getTimeString(self):

        dt = self.getLocalTime()
        if dt.hour >= 6 and dt.hour < 12:
            time_string = "morning"
        elif dt.hour >= 12 and dt.hour < 17:
            time_string = "afternoon"
        elif dt.hour >= 17 and dt.hour < 20:
            time_string = "evening"
        else:
            # time_string = "night"
            time_string = "evening"
        return time_string

    time_of_day_string = property(getTimeString)
    formal_name = property(lambda self: "{0} {1}".format(self.title_name, self.last_name))

    def greetUser(self):
        self.output("Good {0} {1}.".format(self.time_of_day_string, self.formal_name))
        return

    def getLocalTime(self):
        now = datetime.datetime.now(pytz.utc).astimezone(self.timezone)
        return now

    def run(self):
        self.greetUser()


        # for ndx, (option, func) in enumerate(options):
        #     print("{}: {}".format(ndx+1, option))
        # val = input("What would you like me to do? ")
        # result = int(val)

        # # Run the corresponding function.
        # option_function = options[result-1][1]
        # option_function()
        # embed()

        return

    def apologize(self, msg):
        self.output("I'm sorry {0}, I don't know how to do that.".format(self.formal_name))
        return

    def handleCommand(self, cmd):
        if cmd.command == Command.SHOW:
            if "goals list" in cmd.string:
                self.describeGoalsList()
            else:
                self.apologize("I'm sorry. That doesn't make sense to me.")
        return

    def describeGoalsList(self):
        self.output("Your goals are {0}".format(", ".join(self.focus_areas)))
        return

    def outputStatus(self):
        self.output("I don't yet know what your status is.")
        return

    def outputAppointments(self):
        self.output("I'm not set to run your appointments.")

    def output(self, statement):
        print(statement)
        # self.say(statement)
        return

    def input(self, msg):
        # self.output(msg)
        ans = input("{0} ".format(msg))
        return ans

    def audioInput(self, msg):
        import speech_recognition as sr

        r = sr.Recognizer()
        m = sr.Microphone()

        with m as source:
            r.adjust_for_ambient_noise(source)
            try:
                audio = r.listen(source)
                value = r.recognize_google(audio)
                # we need some special handling here to correctly print unicode characters to standard output
                if str is bytes: # this version of Python uses bytes for strings (Python 2)
                    conv_val = "{0}".format(value).encode("utf-8")
                else: # this version of Python uses unicode for strings (Python 3+)
                    conv_val = value
            except LookupError:
                conv_val = ""
        return conv_val

def setActiveProject(session):
    if ActiveProject.projectIsActive():
        lines = ["You are currently working on {}.".format(ActiveProject.getCurrentActivityName())]

        if ActivePomodoro.pomodoroIsActive():
            lines.append("There is {0} left to go in the current pomodoro.")

        print(" ".join(lines))
        if not input("Do you want to switch? ").lower().strip().startswith("y"):
            print("Ok.")
            return
        else:
            if ActivePomodoro.pomodoroIsActive():
                print("Ending pomodoro")
                ActivePomodoro.endActivePomodoro()

            ActiveProject.endActiveProject()

    focusgroups = session.query(model.FocusGroup).all()
    print("What would you like to work on?")
    for (ndx, focus) in enumerate(focusgroups):
        print("{}: {}".format(ndx+1,focus))
    ndx = int(input("Choice? ")) - 1

    activelifegroup = focusgroups[ndx]
    print("What would you like to work on?")
    group_activities = activelifegroup.activities
    for (ndx, potential_activity) in enumerate(group_activities):
        print("{}: {} - expect it will take {}".format(ndx+1, potential_activity.name, potential_activity.expected_time))
    ndx = int(input("Choice? ")) - 1
    activity = group_activities[ndx]

    ActiveProject.startActiveProject(activity)

    return

def endActiveProject(session):
    print("Ending project")
    ActiveProject.endActiveProject()
    return

def startActivePomodoro(session):
    key = "i am ready to work"
    #key = ""
    print("key: {}".format(key))

    # Get input
    while True:
        ret = input("type the key >> ").strip()
        if ret == key: break

    ActivePomodoro.startActivePomodoro()

    activity_name = ActiveProject.getCurrentActivityName()

    st = ActivePomodoro.getStartTime()
    et = st + datetime.timedelta(seconds = 60 * 25)

    sts = st.strftime("%H%M")
    ets = et.strftime("%H%M")

    args = ["Pom: {}".format(activity_name),
            "{}-{}".format(sts,ets),
            ""]

    args[2] = "Starting Pom. 25m left."
    lifedashboard.tasks.say.delay(*args)

    args[2] = "2 minute drill.  Finish up."
    lifedashboard.tasks.say.apply_async(args=args, countdown = 23 * 60)

    args[2] = "Pencils Down."
    lifedashboard.tasks.interrupt.apply_async(args=args, countdown = 25 * 60)

    return
###

class Global:
    def __init__(self):
        self.quit = False

def secretarySpeak(global_struct):
    last_branch = -1

    while not global_struct.quit:
        time.sleep(1)
        # If there is an inactive project, alert
        # If there is an active project but no pomodoro, alert
        # If there is a pomodoro that should be finished, alert

        if not ActiveProject.projectIsActive():
            branch_id = 1
            if not last_branch == branch_id: print("There is no active project; you should start one.")
            last_branch = branch_id

        if ActiveProject.projectIsActive() and not ActivePomodoro.pomodoroIsActive():
            branch_id = 2
            activity_name = ActiveProject.getCurrentActivityName()
            if not last_branch == branch_id: print("There is no active pomodoro for activity {} . Start one.".format(activity_name))
            last_branch = branch_id

        if ActivePomodoro.pomodoroIsActive():
            if ActivePomodoro.getRuntime() >= 25:
                branch_id = 3
                if not last_branch == branch_id: print("Pomodoro is done.  Please end it and start your break.")
                last_branch = branch_id
            else:
                branch_id = 4
                if not last_branch == branch_id:
                    activity_name = ActiveProject.getCurrentActivityName()
                    pom_remainder = 25 - ActivePomodoro.getRuntime()
                    print("You are currently working on a pomodoro for {} that ends in {} minutes".format(activity_name, pom_remainder))
                    last_branch = branch_id
    return

import redis

class RedisVariable:
    def __init__(self, name, type = None):
        self.varname = name
        self.type = type if type is not None else False
        self.r = redis.StrictRedis(host='localhost', port=6379, db=0)
        return

    def getValue(self):
        value = self.r.get(self.varname)
        if value is None: return self.type()
        value_str = str(value, 'utf-8')
        if self.type:
            value = self.type(value_str)
        else:
            value = value_str
        return value

    def setValue(self, val):
        self.r.set(self.varname, val)
        return

    def __repr__(self):
        return str("xR{}".format(self.value))

    value = property(getValue, setValue)

class Status:
    pass

class UserPresenceStatus(Status):
    AWAY = 0
    AT_COMPUTER = 1

    _user_presence = RedisVariable("user_presence_status", int)

    def setUserPresence(self, var):
        self._user_presence.value = var

    user_presence = property(lambda self: self._user_presence.value, setUserPresence)

    @classmethod
    def advanceState(self):
        self.user_presence = 0 if self.user_presence == 1 else 1
        return

    def __repr__(self):
        if self.user_presence == 0:
            return "Away"
        elif self.user_presence == 1:
            return "Present"


class SecretaryStatus(Status):
    START_OF_DAY      = 0
    MONITOR_MORNING   = 1
    MONITOR_AFTERNOON = 2
    MONITOR_EVENING   = 3
    OFF_FOR_NIGHT     = 4

    def advanceState(self, next_state = None):
        self.secretary_status = (self.secretary_status+1)%5
        return

    def setSecretaryStatus(self, var):
        self._secretary_status.value = var

    _secretary_status = RedisVariable("secretary_status", int)
    secretary_status = property(lambda self: self._secretary_status.value, setSecretaryStatus)

    def __repr__(self):
        if self.secretary_status == self.START_OF_DAY:
            return "start of day"
        elif self.secretary_status == self.MONITOR_MORNING:
            return "monitor_morning"
        elif self.secretary_status == self.MONITOR_AFTERNOON:
            return "monitor_afternoon"
        elif self.secretary_status == self.MONITOR_EVENING:
            return "monitor_evening"
        elif self.secretary_status == self.OFF_FOR_NIGHT:
            return "off_for_night"

class WorkStatus(Status):
    WAITING_FOR_WORK_ACTION = 0
    POMODORO = 1
    WAITING_FOR_BREAK = 2
    BREAK = 3

    def setWorkStatus(self, var):
        self._user_work_status.value = var

    _user_work_status = RedisVariable("user_work_status", int)
    user_work_status = property(lambda self: self._user_work_status.value, setWorkStatus)

    # @classmethod
    def advanceState(self, next_state = None):
        self.user_work_status = (self.user_work_status + 1) % 4
        return

    def __repr__(self):
        if self.user_work_status == self.WAITING_FOR_WORK_ACTION:
            return "waiting_for_work_action"
        if self.user_work_status == self.POMODORO:
            return "pomodoro"
        if self.user_work_status == self.WAITING_FOR_BREAK:
            return "waiting_for_break"
        if self.user_work_status == self.BREAK:

            return "break"

def takeBreak(session):
    if ActivePomodoro.pomodoroIsActive():
        print("There is an active pomodoro for {} more minutes")
        return
    else:
        bs = BreakStatus()
        if bs.on_break:
            print("Already on break for {} more minutes.")
            return
        else:

            possible_breaks = ["meditate and focus on you concentration",
                               "stretch", "do 20 pushups", "massage your arm",
                               "play a quick game of geometry wars", "read a poem",
                               "check facebook", "do some dishes"]

            bs.startBreak(5)
            print("Starting 5 minute break.")
            args = ("Break ended", "", "Break is done.  Time to get back to work")
            lifedashboard.tasks.say.apply_async(args=args, countdown = 5 * 60)
    return

def endBreak(session):
    bs = BreakStatus()
    if not bs.on_break:
        print("Not on break.")
        return
    else:
        print("Ending Break")
        bs.endBreak()
        return

def secretaryInput(global_struct):
    # Start an active project
    # Start a pomodoro if none is active
    # End a running pomodoro
    # End an active Project.

    session = model.session()
    while not global_struct.quit:
        user_input = input("").strip().lower()
        if user_input in ['quit', 'q']:
            global_struct.quit = True
            continue
        elif user_input in ["list", "l"]:
            showHelp(session)
        elif user_input == 's':
            showStatus(session)
        elif user_input == 'ss':
            showDailyStatus(session)
        elif user_input == 'start ap':
            setActiveProject(session)
        elif user_input == 'start pom':
            startActivePomodoro(session)
        elif user_input == 'end pom':
            endActivePomodoro(session)
        elif user_input == 'end ap':
            endActiveProject(session)
        elif user_input == 'break':
            takeBreak(session)
        elif user_input == 'end break':
            endBreak(session)
        else:
            print("Unrecognized input - {}".format(user_input))

    session.commit()
    session.flush()
    session.close()
    return

def showHelp(session):
    print("I know the following commands.")
    print("------------------------------------------")
    print("s             # Show current status")
    # print("ss            # Show daily status")
    #print("start day     # create your daily schedule.")
    print("start ap      # start active project")
    print("end ap        # End active project")
    print("start pom     # Start pomodoro")
    print("end pom       # End pomodoro")
    print("break         # Take a break.")
    print("end break         # End a break.")
    # print("a             # Away from computer")
    # print("b             # Away from computer")

    # print("res          # Record Emotional State")
    print("------------------------------------------")
    return

def endActivePomodoro(session):
    ActivePomodoro.endActivePomodoro()
    return

def showStatus(session):
    if ActiveProject.projectIsActive():
        print("You are working on {}".format(ActiveProject.getCurrentActivityName()))
    else:
        print("You are not currently working on any active projects.")
        return

    if ActivePomodoro.pomodoroIsActive():
        minutes_left = 25 - ActivePomodoro.getRuntime()
        end_time = datetime.datetime.utcnow() + datetime.timedelta(seconds = minutes_left * 60)
        end_time_str = end_time.strftime("%H%M")
        print("There is an active pomodoro that will end in {} minutes at {}.".format(minutes_left, end_time_str))
    else:
        print("No pomodoros are running currently.")
    return

def runApp():
    try:
        global_struct = Global()
        thread = threading.Thread(target = secretarySpeak, args = (global_struct, ))
        thread.start()

        secretaryInput(global_struct)
    except KeyboardInterrupt:
        print("Got keyboard interrupt.")
        global_struct.quit = True
    thread.join()

    return

###
class RedisVariable:
    def __init__(self, name, type = None):
        self.varname = name
        self.type = type if type is not None else False
        self.r = redis.StrictRedis(host='localhost', port=6379, db=0)
        return

    def getValue(self):
        value = self.r.get(self.varname)
        if value is None: return self.type()
        value_str = str(value, 'utf-8')
        if self.type:
            value = self.type(value_str)
        else:
            value = value_str
        return value

    def setValue(self, val):
        self.r.set(self.varname, val)
        return

    def __repr__(self):
        return str("xR{}".format(self.value))

    value = property(getValue, setValue)

class RedisActiveRecord:
    @staticmethod
    def getRedis():
        r = redis.StrictRedis(host='localhost', port=6379, db=0)
        return r

    @classmethod
    def getTimeStr(cls):
        return datetime.datetime.utcnow().replace(second=0, microsecond=0).isoformat()

class BreakStatus:
    def __init__(self):
        self.break_active = RedisVariable("break_active", int)
        self.break_start = RedisVariable("break_start", str)
        self.break_length = RedisVariable("break_length_min", int)
        self.break_end = RedisVariable("break_end", str)
        return

    def startBreak(self, break_length = 5):
        assert not self.break_active.value, "Cannot start a break that is active"
        tm = datetime.datetime.utcnow()
        self.break_active.value = 1
        self.break_start.value = self.writeDatetimeToString(datetime.datetime.utcnow())
        self.break_end.value = self.writeDatetimeToString(datetime.datetime.utcnow() + datetime.timedelta(seconds = 60 * break_length))
        self.break_length.value = break_length
        return

    def __repr__(self):
        if not self.break_active.value:
            return "Not active"
        else:
            pdb.set_trace()
            break_string = self.break_end.value
            break_dt = self.parseDatetimeFromString(break_string)
            break_fin_string = self.getTimeStringFromVar(break_dt)
            return "Active: Ends at {}".format()

    on_break = property(lambda self : self.break_active.value)

    def getTimeStringFromVar(self, dt):
        return self.parseDatetimeFromString(dt).strftime("%H%M")

    def writeDatetimeToString(self, dt):
        return dt.replace(second=0, microsecond=0).isoformat()

    def parseDatetimeFromString(self, string):
        if string:
            return isodate.parse_date(string)
        else:
            return datetime.datetime(1970,1,1)

    def endBreak(self):
        assert self.break_active, "Break must me active."
        self.break_active.value = 0
        self.break_start.value = ""
        self.break_length.value = 0
        self.break_end.value = ""
        return


class ActivePomodoro(RedisActiveRecord):
    @classmethod
    def showState(cls):
        r = cls.getRedis()
        print("pomodoro_active: {}".format(r.get("pomodoro_active")))
        print("pomodoro_start_time: {}".format(r.get("pomodoro_start_time")))
        print("pomodoro_end_time: {}".format(r.get("pomodoro_end_time")))
        print("pomodoro_message: {}".format(r.get("pomodoro_message")))
        return

    @classmethod
    def clearState(cls):
        r = cls.getRedis()
        r.delete("pomodoro_active")
        r.delete("pomodoro_start_time")
        r.delete("pomodoro_end_time")
        r.delete("pomodoro_message")
        r.set("pomodoro_active", 0)
        return

    @classmethod
    def startActivePomodoro(cls):
        assert ActiveProject.projectIsActive(), "Project must be active to start a pomodoro."
        assert not cls.pomodoroIsActive(), "Pomodoro must not be currently active."
        r = cls.getRedis()
        r.delete("pomodoro_active")
        r.delete("pomodoro_start_time")
        r.delete("pomodoro_end_time")
        r.delete("pomodoro_message")

        r.set("pomodoro_active", "1")
        r.set("pomodoro_start_time", cls.getTimeStr())

        return

    @classmethod
    def endActivePomodoro(cls):

        assert cls.pomodoroIsActive(), "Pomodoro must be active."
        r = cls.getRedis()
        msg = input("Pom message >> ")
        r.set("pomodoro_active", "0")
        r.set("pomodoro_end_time", cls.getTimeStr())

        r.set("pomodoro_message", msg)

        session = model.session()
        st_str = str(r.get("pomodoro_start_time"), 'utf-8')
        et_str = str(r.get("pomodoro_end_time"), 'utf-8')
        msg_str = str(r.get("pomodoro_message"), 'utf-8')
        activity_record = session.query(model.ActivityRecord).get(int(r.get("active_activityrecord_id")))
        pom = model.Pomodoro(start_time = isodate.parse_date(st_str),
                             end_time = isodate.parse_date(et_str),
                             message = msg_str,
                             activity_record = activity_record)
        session.add(pom)
        session.commit()

        # ActiveProject.addPomodoro(pom_id)

        return

    @classmethod
    def getStartTime(cls):
        r = cls.getRedis()
        time_str = str(r.get("pomodoro_start_time"), 'utf-8')
        return isodate.parse_datetime(time_str)

    @classmethod
    def getRuntime(cls):
        assert cls.pomodoroIsActive(), "Pomodoro must be active"
        start_time = cls.getStartTime()
        return int((datetime.datetime.utcnow() - start_time).total_seconds() / 60)

    @classmethod
    def pomodoroIsActive(cls):
        r = cls.getRedis()
        val = r.get("pomodoro_active")
        return val is not None and int(val)

class ActiveProject(RedisActiveRecord):
    @classmethod
    def showState(cls):
        r = cls.getRedis()
        print("active: {}".format(r.get("active")))
        print("active_start_time: {}".format(r.get("active_start_time")))
        print("active_end_time: {}".format(r.get("active_end_time")))
        print("active_activity_id: {}".format(r.get("active_activity_id")))
        print("active_pomodoro_list: {}".format(r.get("active_pomodoro_list")))
        print("active_activityrecord_id: {}".format(r.get("active_active_project_id")))
        return

    @classmethod
    def clearState(cls):
        r = cls.getRedis()
        r.delete("active")
        r.delete("active_start_time")
        r.delete("active_end_time")
        r.delete("active_activity_id")
        r.delete("active_pomodoro_list")
        r.delete("active_activityrecord_id")
        r.delete("active_activity_name")
        r.set("active", 0)
        return


    @classmethod
    def startActiveProject(cls, activity):
        assert not cls.projectIsActive(), "Project must not be currently active."
        r = cls.getRedis()
        r.delete("active")
        r.delete("active_start_time")
        r.delete("active_end_time")
        r.delete("active_activity_id")
        r.delete("active_pomodoro_list")
        r.delete("active_activityrecord_id")
        r.delete("active_activity_name")

        r.set("active", "1")
        start_time_str = cls.getTimeStr()
        r.set("active_start_time", start_time_str)
        r.set("active_activity_id", activity.id)
        r.set("active_activity_name", activity.name)

        session = model.session()
        activity_loc = session.query(model.Activity).get(activity.id)
        activityrecord = model.ActivityRecord(activity = activity_loc,
                                              start_time = isodate.parse_datetime(start_time_str))
        session.add(activityrecord)
        session.commit()
        r.set("active_activityrecord_id", activityrecord.id)
        return

    @classmethod
    def endActiveProject(cls):
        assert cls.projectIsActive(), "Project must be active."
        assert not ActivePomodoro.pomodoroIsActive(), "Must close all Pomodoros first."

        r = cls.getRedis()

        end_time_str = cls.getTimeStr()
        session = model.session()


        active_activityrecord_id = int(r.get("active_activityrecord_id"))
        act_rec = session.query(model.ActivityRecord).get(active_activityrecord_id)

        message = input("active project end summary >> ")

        act_rec.end_time = isodate.parse_datetime(end_time_str)
        act_rec.message = message
        session.add(act_rec)
        session.commit()

        cls.clearState()
        return

    @classmethod
    def projectIsActive(cls):
        r = cls.getRedis()
        val = r.get("active")
        return int(val)

    @classmethod
    def getCurrentActivityName(cls):
        assert cls.projectIsActive(), "Project must be active"
        r = cls.getRedis()
        activity_name = r.get("active_activity_name")
        return str(activity_name, 'utf-8')

    # @classmethod
    # def getCurrentActivity(cls, session):
    #     if not cls.projectIsActive(): return None
    #     r = cls.getRedis()
    #     active_activity_id = int(r.get("active_activity_id"))
    #     return session.query(model.Activity).get(active_activity_id)

    @classmethod
    def setActivity(cls, activity):
        activity_id = activity_id

    @classmethod
    def addPomodoro(cls, pomodoro):
        pom_id = pomodoro.id
        r = cls.getRedis()
        r.rpush("active_pomodoro_list", pom_id)
        return

    def clearActiveProject(self):
        return

def runActivity(activity):
    print("Preparing to do some work for {}".format(activity.name))
    print("Typical length: {}".format(activity.expected_time))
    num_hours = float(input("How Long do you want to do this? "))

    return

def showDailyStatus(session):
    print("Daily Status - IMPLEMENT")
    return



## TESTING CODE
## TESTING CODE
## TESTING CODE



# session = model.session()
# activities = session.query(model.Activity).all()
# emotions = session.query(model.Emotion).all()
# emotion_ndxs = list(range(len(emotions)))

# for ndx in range(25):
#     activity = random.choice(activities)
#     month = random.randint(1,12)
#     day = random.randint(1,28)
#     hour = random.randint(8, 18)
#     pomodoro = random.randint(1,5)
#     duration = pomodoro * 30 * 60 + random.randint(0, 60 * 20)

#     start_time = datetime.datetime(month = month, day = day, year = 2015, hour = hour )
#     end_time = start_time + datetime.timedelta(seconds = duration)

#     assoc_num_emotions = random.randint(1, len(emotions))
#     random.shuffle(emotion_ndxs)

#     activity_record = model.ActivityRecord(start_time = start_time, end_time = end_time, pomodoro = pomodoro, activity = activity, initial_emotions = emotions[:assoc_num_emotions])
#     session.add(activity_record)
# session.commit()



# def tmp():

# association_table = Table('association', Base.metadata,
#     Column('left_id', Integer, ForeignKey('left.id')),
#     Column('right_id', Integer, ForeignKey('right.id'))
# )

# class Parent(Base):
#     __tablename__ = 'left'
#     id = Column(Integer, primary_key=True)
#     name = Column(String)
#     def __repr__(self):
#         return self.name
#     children = relationship(
#         "Child",
#         secondary=association_table,
#         back_populates="parents")

# class Child(Base):
#     __tablename__ = 'right'
#     id = Column(Integer, primary_key=True)
#     name = Column(String)
#     parents = relationship(
#         "Parent",
#         secondary=association_table,
#         back_populates="children")
#     def __repr__(self):
#         return self.name








#     session = model.session()

#     p1 = model.Parent(name="Susan")
#     p2 = model.Parent(name="Mark")
#     c1 = model.Child(name="Katie")
#     c2 = model.Child(name="Aliya")
#     p3 = model.Parent(name="Carol")
#     p4 = model.Parent(name="Ray")
#     c3 = model.Child(name="Nathan")
#     c4 = model.Child(name="Daniel")
#     c5 = model.Child(name="Michael")

#     session.add(p1)
#     session.add(p2)
#     session.add(p3)
#     session.add(p4)

#     session.add(c1)
#     session.add(c2)
#     session.add(c3)
#     session.add(c4)
#     session.add(c5)

#     p1.children = [c1,c2]
#     p2.children = [c1,c2]

#     p3.children = [c3,c4,c5]
#     p4.children = [c3,c4,c5]

#     session.commit()
#     parent = session.query(Parent).first()
#     ## END TESTING CODE
#     ## END TESTING CODE
#     ## END TESTING CODE


def main():

    # ActiveProject.clearState()
    # ActivePomodoro.clearState()

    app = Secretary()
    app.initialize()
    runApp()



    # embed()
    # app.run()

    return

if __name__ == '__main__':
    main()
